<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AutoGen Docs · PureSpecial.jl</title><meta name="title" content="AutoGen Docs · PureSpecial.jl"/><meta property="og:title" content="AutoGen Docs · PureSpecial.jl"/><meta property="twitter:title" content="AutoGen Docs · PureSpecial.jl"/><meta name="description" content="Documentation for PureSpecial.jl."/><meta property="og:description" content="Documentation for PureSpecial.jl."/><meta property="twitter:description" content="Documentation for PureSpecial.jl."/><meta property="og:url" content="https://cyhan.dev/PureSpecial.jl/specfun/autodocs/"/><meta property="twitter:url" content="https://cyhan.dev/PureSpecial.jl/specfun/autodocs/"/><link rel="canonical" href="https://cyhan.dev/PureSpecial.jl/specfun/autodocs/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PureSpecial.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../special-functions/">Special Function Packages</a></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Gamma Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/gamma/">Gamma Functions</a></li><li><a class="tocitem" href="../../reference/gamma/gamma/"><code>gamma</code></a></li></ul></li><li><a class="tocitem" href="../../reference/exp-integral/">Exponential Integrals</a></li><li><a class="tocitem" href="../../reference/error/">Error Functions</a></li><li><a class="tocitem" href="../../reference/autodocs/">Autogen Docs</a></li></ul></li><li><span class="tocitem">AbstractSpecialFunctions</span><ul><li><a class="tocitem" href="../../api/">AbstractSpecialFunctions</a></li><li><a class="tocitem" href="../../api/gamma/">Gamma Functions</a></li><li><a class="tocitem" href="../../api/exp-int/">Exponential Integrals</a></li><li><a class="tocitem" href="../../api/error/">Error Functions</a></li></ul></li><li><span class="tocitem">Dev doc</span><ul><li><a class="tocitem" href="../../impls/">Implementations</a></li><li><a class="tocitem" href="../../scipy.special/">scipy.special</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">specfun.f</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Specfun</a></li><li><a class="tocitem" href="../book-chapters/">Functions by Chapter</a></li><li><a class="tocitem" href="../book-index/">Function Index in CoSF</a></li><li class="is-active"><a class="tocitem" href>AutoGen Docs</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docs"><span>Docs</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../cephes/">Cephes</a></li><li><a class="tocitem" href="../../faddeeva/">Faddeeva</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Dev doc</a></li><li><a class="is-disabled">specfun.f</a></li><li class="is-active"><a href>AutoGen Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AutoGen Docs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/inkydragon/PureSpecial.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/inkydragon/PureSpecial.jl/blob/main/docs/src/specfun/autodocs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AutoGen-Docs"><a class="docs-heading-anchor" href="#AutoGen-Docs">AutoGen Docs</a><a id="AutoGen-Docs-1"></a><a class="docs-heading-anchor-permalink" href="#AutoGen-Docs" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PureSpecial.Specfun.SF_EULER_GAMMA"><code>PureSpecial.Specfun.SF_EULER_GAMMA</code></a></li><li><a href="#PureSpecial.Specfun.SF_EULER_GAMMA_00"><code>PureSpecial.Specfun.SF_EULER_GAMMA_00</code></a></li><li><a href="#PureSpecial.Specfun.SF_EULER_GAMMA_28"><code>PureSpecial.Specfun.SF_EULER_GAMMA_28</code></a></li><li><a href="#PureSpecial.Specfun.SF_INF300"><code>PureSpecial.Specfun.SF_INF300</code></a></li><li><a href="#PureSpecial.Specfun.SF_PI"><code>PureSpecial.Specfun.SF_PI</code></a></li><li><a href="#PureSpecial.Specfun._GAM0_G"><code>PureSpecial.Specfun._GAM0_G</code></a></li><li><a href="#PureSpecial.Specfun._LGAMA_A"><code>PureSpecial.Specfun._LGAMA_A</code></a></li><li><a href="#PureSpecial.Specfun.airyb-Tuple{Float64}"><code>PureSpecial.Specfun.airyb</code></a></li><li><a href="#PureSpecial.Specfun.airyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><code>PureSpecial.Specfun.airyzo</code></a></li><li><a href="#PureSpecial.Specfun.aswfa-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.aswfa</code></a></li><li><a href="#PureSpecial.Specfun.bernoa-Tuple{Int64}"><code>PureSpecial.Specfun.bernoa</code></a></li><li><a href="#PureSpecial.Specfun.bernob-Tuple{Int64}"><code>PureSpecial.Specfun.bernob</code></a></li><li><a href="#PureSpecial.Specfun.beta-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.beta</code></a></li><li><a href="#PureSpecial.Specfun.bjndd-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.bjndd</code></a></li><li><a href="#PureSpecial.Specfun.cchg-Tuple{Float64, Float64, ComplexF64}"><code>PureSpecial.Specfun.cchg</code></a></li><li><a href="#PureSpecial.Specfun.cerf-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cerf</code></a></li><li><a href="#PureSpecial.Specfun.cerzo-Tuple{Vector{ComplexF64}, Int64}"><code>PureSpecial.Specfun.cerzo</code></a></li><li><a href="#PureSpecial.Specfun.cfc-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cfc</code></a></li><li><a href="#PureSpecial.Specfun.cfs-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cfs</code></a></li><li><a href="#PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><code>PureSpecial.Specfun.cgama</code></a></li><li><a href="#PureSpecial.Specfun.chgm-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgm</code></a></li><li><a href="#PureSpecial.Specfun.chgm_kernel-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgm_kernel</code></a></li><li><a href="#PureSpecial.Specfun.chgu-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgu</code></a></li><li><a href="#PureSpecial.Specfun.chgubi-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgubi</code></a></li><li><a href="#PureSpecial.Specfun.chguit-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chguit</code></a></li><li><a href="#PureSpecial.Specfun.chgul-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgul</code></a></li><li><a href="#PureSpecial.Specfun.chgus-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgus</code></a></li><li><a href="#PureSpecial.Specfun.cisia-Tuple{Float64}"><code>PureSpecial.Specfun.cisia</code></a></li><li><a href="#PureSpecial.Specfun.cisib-Tuple{Float64}"><code>PureSpecial.Specfun.cisib</code></a></li><li><a href="#PureSpecial.Specfun.cpbdn-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpbdn</code></a></li><li><a href="#PureSpecial.Specfun.cpdla-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpdla</code></a></li><li><a href="#PureSpecial.Specfun.cpdsa-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpdsa</code></a></li><li><a href="#PureSpecial.Specfun.cpsi-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cpsi</code></a></li><li><a href="#PureSpecial.Specfun.djn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.djn_zeros</code></a></li><li><a href="#PureSpecial.Specfun.dvla-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.dvla</code></a></li><li><a href="#PureSpecial.Specfun.dvsa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.dvsa</code></a></li><li><a href="#PureSpecial.Specfun.dyn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.dyn_zeros</code></a></li><li><a href="#PureSpecial.Specfun.e1xa-Tuple{Float64}"><code>PureSpecial.Specfun.e1xa</code></a></li><li><a href="#PureSpecial.Specfun.e1xb-Tuple{Float64}"><code>PureSpecial.Specfun.e1xb</code></a></li><li><a href="#PureSpecial.Specfun.e1z-Tuple{ComplexF64}"><code>PureSpecial.Specfun.e1z</code></a></li><li><a href="#PureSpecial.Specfun.eix-Tuple{Float64}"><code>PureSpecial.Specfun.eix</code></a></li><li><a href="#PureSpecial.Specfun.eixz-Tuple{ComplexF64}"><code>PureSpecial.Specfun.eixz</code></a></li><li><a href="#PureSpecial.Specfun.envj-Tuple{Any, Any}"><code>PureSpecial.Specfun.envj</code></a></li><li><a href="#PureSpecial.Specfun.enxa-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.enxa</code></a></li><li><a href="#PureSpecial.Specfun.enxb-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.enxb</code></a></li><li><a href="#PureSpecial.Specfun.erf-Tuple{ComplexF64}"><code>PureSpecial.Specfun.erf</code></a></li><li><a href="#PureSpecial.Specfun.erf-Tuple{Float64}"><code>PureSpecial.Specfun.erf</code></a></li><li><a href="#PureSpecial.Specfun.eulera-Tuple{Int64}"><code>PureSpecial.Specfun.eulera</code></a></li><li><a href="#PureSpecial.Specfun.eulerb-Tuple{Int64}"><code>PureSpecial.Specfun.eulerb</code></a></li><li><a href="#PureSpecial.Specfun.fcs-Tuple{Float64}"><code>PureSpecial.Specfun.fcs</code></a></li><li><a href="#PureSpecial.Specfun.fcszo-Tuple{Vector{ComplexF64}, Int64, Int64}"><code>PureSpecial.Specfun.fcszo</code></a></li><li><a href="#PureSpecial.Specfun.ffk-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.ffk</code></a></li><li><a href="#PureSpecial.Specfun.gaih-Tuple{Float64}"><code>PureSpecial.Specfun.gaih</code></a></li><li><a href="#PureSpecial.Specfun.gam0-Tuple{Float64}"><code>PureSpecial.Specfun.gam0</code></a></li><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>PureSpecial.Specfun.gamma2</code></a></li><li><a href="#PureSpecial.Specfun.incob-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.incob</code></a></li><li><a href="#PureSpecial.Specfun.incog-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.incog</code></a></li><li><a href="#PureSpecial.Specfun.itairy-Tuple{Float64}"><code>PureSpecial.Specfun.itairy</code></a></li><li><a href="#PureSpecial.Specfun.itsh0-Tuple{Float64}"><code>PureSpecial.Specfun.itsh0</code></a></li><li><a href="#PureSpecial.Specfun.itsl0-Tuple{Float64}"><code>PureSpecial.Specfun.itsl0</code></a></li><li><a href="#PureSpecial.Specfun.itth0-Tuple{Float64}"><code>PureSpecial.Specfun.itth0</code></a></li><li><a href="#PureSpecial.Specfun.jdzo-Tuple{Int64, Vector{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>PureSpecial.Specfun.jdzo</code></a></li><li><a href="#PureSpecial.Specfun.jdzo-Tuple{Int64}"><code>PureSpecial.Specfun.jdzo</code></a></li><li><a href="#PureSpecial.Specfun.jn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.jn_zeros</code></a></li><li><a href="#PureSpecial.Specfun.jynbh-Tuple{Float64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.jynbh</code></a></li><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.jyndd</code></a></li><li><a href="#PureSpecial.Specfun.jyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><code>PureSpecial.Specfun.jyzo</code></a></li><li><a href="#PureSpecial.Specfun.klvna-Tuple{Float64}"><code>PureSpecial.Specfun.klvna</code></a></li><li><a href="#PureSpecial.Specfun.klvnb"><code>PureSpecial.Specfun.klvnb</code></a></li><li><a href="#PureSpecial.Specfun.klvnzo-Tuple{Int64, Int64}"><code>PureSpecial.Specfun.klvnzo</code></a></li><li><a href="#PureSpecial.Specfun.kmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.kmn</code></a></li><li><a href="#PureSpecial.Specfun.lgama-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.lgama</code></a></li><li><a href="#PureSpecial.Specfun.lpmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.lpmns</code></a></li><li><a href="#PureSpecial.Specfun.lpmv-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.lpmv</code></a></li><li><a href="#PureSpecial.Specfun.lpmv0-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.lpmv0</code></a></li><li><a href="#PureSpecial.Specfun.lqmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.lqmns</code></a></li><li><a href="#PureSpecial.Specfun.msta1-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.msta1</code></a></li><li><a href="#PureSpecial.Specfun.msta2-Tuple{Float64, Int64, Int64}"><code>PureSpecial.Specfun.msta2</code></a></li><li><a href="#PureSpecial.Specfun.pbdv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>PureSpecial.Specfun.pbdv</code></a></li><li><a href="#PureSpecial.Specfun.pbvv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>PureSpecial.Specfun.pbvv</code></a></li><li><a href="#PureSpecial.Specfun.pbwa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.pbwa</code></a></li><li><a href="#PureSpecial.Specfun.psi-Tuple{T} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.psi</code></a></li><li><a href="#PureSpecial.Specfun.rmn1-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rmn1</code></a></li><li><a href="#PureSpecial.Specfun.rmn2l-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rmn2l</code></a></li><li><a href="#PureSpecial.Specfun.rmn2sp-NTuple{7, Any}"><code>PureSpecial.Specfun.rmn2sp</code></a></li><li><a href="#PureSpecial.Specfun.rswfp-Union{Tuple{T}, Tuple{Int64, Int64, T, T, T, Int64}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rswfp</code></a></li><li><a href="#PureSpecial.Specfun.sckb-Union{Tuple{T}, Tuple{Int64, Int64, T, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sckb</code></a></li><li><a href="#PureSpecial.Specfun.sdmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sdmn</code></a></li><li><a href="#PureSpecial.Specfun.segv-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.segv</code></a></li><li><a href="#PureSpecial.Specfun.sphj-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sphj</code></a></li><li><a href="#PureSpecial.Specfun.sphy-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sphy</code></a></li><li><a href="#PureSpecial.Specfun.stvh0-Tuple{Float64}"><code>PureSpecial.Specfun.stvh0</code></a></li><li><a href="#PureSpecial.Specfun.stvh1-Tuple{Float64}"><code>PureSpecial.Specfun.stvh1</code></a></li><li><a href="#PureSpecial.Specfun.stvhv-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.stvhv</code></a></li><li><a href="#PureSpecial.Specfun.stvl0-Tuple{Float64}"><code>PureSpecial.Specfun.stvl0</code></a></li><li><a href="#PureSpecial.Specfun.vvla-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.vvla</code></a></li><li><a href="#PureSpecial.Specfun.vvsa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.vvsa</code></a></li><li><a href="#PureSpecial.Specfun.yn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.yn_zeros</code></a></li></ul><h2 id="Docs"><a class="docs-heading-anchor" href="#Docs">Docs</a><a id="Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Docs" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun"><a class="docstring-binding" href="#PureSpecial.Specfun"><code>PureSpecial.Specfun</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Special functions in pure julia.</p><p>Translated from <code>specfun.f</code></p><pre><code class="language-fortran hljs">C
C       COMPUTATION OF SPECIAL FUNCTIONS
C
C          Shanjie Zhang and Jianming Jin
C
C       Copyrighted but permission granted to use code in programs.
C       Buy their book &quot;Computation of Special Functions&quot;, 1996, John Wiley &amp; Sons, Inc.
C</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/Specfun.jl#L4-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.SF_EULER_GAMMA"><a class="docstring-binding" href="#PureSpecial.Specfun.SF_EULER_GAMMA"><code>PureSpecial.Specfun.SF_EULER_GAMMA</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Euler&#39;s Constant γ</p><p>Same as: Base.MathConstants.eulergamma</p><pre><code class="language-julia-repl hljs">julia&gt; Float64(Base.MathConstants.eulergamma)
0.5772156649015329</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/const.jl#L31-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.SF_EULER_GAMMA_00"><a class="docstring-binding" href="#PureSpecial.Specfun.SF_EULER_GAMMA_00"><code>PureSpecial.Specfun.SF_EULER_GAMMA_00</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Euler&#39;s Constant γ</p><pre><code class="language-julia-repl hljs">julia&gt; Float64(Base.MathConstants.eulergamma)
0.5772156649015329

julia&gt; 0.57721566490153_00  # imprecise
0.57721566490153</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/const.jl#L57-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.SF_EULER_GAMMA_28"><a class="docstring-binding" href="#PureSpecial.Specfun.SF_EULER_GAMMA_28"><code>PureSpecial.Specfun.SF_EULER_GAMMA_28</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Euler&#39;s Constant γ</p><pre><code class="language-julia-repl hljs">julia&gt; Float64(Base.MathConstants.eulergamma)
0.5772156649015329

julia&gt; 0.57721566490153_28  # imprecise
0.5772156649015328</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/const.jl#L43-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.SF_INF300"><a class="docstring-binding" href="#PureSpecial.Specfun.SF_INF300"><code>PureSpecial.Specfun.SF_INF300</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p><code>1e300</code> used as <code>+Inf</code> in <code>specfun.f</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/const.jl#L5-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.SF_PI"><a class="docstring-binding" href="#PureSpecial.Specfun.SF_PI"><code>PureSpecial.Specfun.SF_PI</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>The constant π.</p><p>Same as: Base.MathConstants.pi</p><pre><code class="language-julia-repl hljs">julia&gt; Float64(Base.MathConstants.pi)
3.141592653589793</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/const.jl#L18-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun._GAM0_G"><a class="docstring-binding" href="#PureSpecial.Specfun._GAM0_G"><code>PureSpecial.Specfun._GAM0_G</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Ref</p><ul><li>DLMF 5.7.1,5.7.2</li><li>Wrench, J. W. (1968).   Concerning two series for the gamma function.   Mathematics of Computation, 22(103), 617-626.   https://www.jstor.org/stable/2004538</li></ul><p>TODO: The coefficients are not consistent with those in the paper</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L20-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun._LGAMA_A"><a class="docstring-binding" href="#PureSpecial.Specfun._LGAMA_A"><code>PureSpecial.Specfun._LGAMA_A</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Coefficients for the series expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L150-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.airyb-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.airyb-Tuple{Float64}"><code>PureSpecial.Specfun.airyb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">airyb(x::Float64)</code></pre><p>Compute Airy functions and their derivatives.</p><p><strong>Input</strong></p><ul><li><code>x</code>: Argument of Airy function</li></ul><p><strong>Output</strong></p><ul><li>(ai, bi, ad, bd)<ul><li><code>ai</code>: Ai(x)</li><li><code>bi</code>: Bi(x)</li><li><code>ad</code>: Ai&#39;(x)</li><li><code>bd</code>: Bi&#39;(x)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/airy.jl#L13-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.airyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><a class="docstring-binding" href="#PureSpecial.Specfun.airyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><code>PureSpecial.Specfun.airyzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">airyzo(
    nt::Int, kf::Int, 
    xa::Vector{Float64}, xb::Vector{Float64},
    xc::Vector{Float64}, xd::Vector{Float64}
)</code></pre><p>Compute the first NT zeros of Airy functions Ai(x) and Ai&#39;(x), a and a&#39;, and the associated values of Ai(a&#39;) and Ai&#39;(a); and the first NT zeros of Airy functions Bi(x) and Bi&#39;(x), b and b&#39;, and the associated values of Bi(b&#39;) and Bi&#39;(b).</p><p><strong>Example</strong></p><pre><code class="language-jl hljs">nt = 4;
a,b,c,d = zeros(nt),zeros(nt),zeros(nt),zeros(nt)
airyzo(nt, 1, a,b,c,d)
@show a b c d;</code></pre><p><strong>Input</strong></p><ul><li><code>NT</code> –- Total number of zeros</li><li><code>KF</code> –- Function code<ul><li>KF=1 for Ai(x) and Ai&#39;(x)</li><li>KF=2 for Bi(x) and Bi&#39;(x)</li></ul></li></ul><p><strong>Output</strong></p><ul><li><code>XA(m)</code> –- a, the m-th zero of Ai(x) or           b, the m-th zero of Bi(x)</li><li><code>XB(m)</code> –- a&#39;, the m-th zero of Ai&#39;(x) or           b&#39;, the m-th zero of Bi&#39;(x)</li><li><code>XC(m)</code> –- Ai(a&#39;) or Bi(b&#39;)</li><li><code>XD(m)</code> –- Ai&#39;(a) or Bi&#39;(b)           ( m –- Serial number of zeros )</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.airyb-Tuple{Float64}"><code>Specfun.airyb</code></a> for computing Airy functions and their derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/airy.jl#L214-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.aswfa-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.aswfa-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.aswfa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the prolate and oblate spheroidal angular functions of the first kind and their derivatives</p><p>Input :  </p><ul><li><code>m</code>  –- Mode parameter,  m = 0,1,2,...</li><li><code>n</code>  –- Mode parameter,  n = m,m+1,...</li><li><code>c</code>  –- Spheroidal parameter</li><li><code>x</code>  –- Argument of angular function, |x| ≤ 1.0</li><li><code>KD</code> –- Function code<ul><li><code>KD= 1</code> for prolate;</li><li><code>KD=-1</code> for oblate</li></ul></li><li><code>cv</code> –- Characteristic value</li></ul><p>Output: <code>(s1f, s1d)</code></p><ul><li><code>s1f</code> –- Angular function of the first kind</li><li><code>s1d</code> –- Derivative of the angular function of       the first kind</li></ul><p>Call:</p><ul><li><a href="#PureSpecial.Specfun.sdmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.sdmn</code></a></li><li><a href="#PureSpecial.Specfun.sckb-Union{Tuple{T}, Tuple{Int64, Int64, T, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.sckb</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L378-L400">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.bernoa-Tuple{Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.bernoa-Tuple{Int64}"><code>PureSpecial.Specfun.bernoa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Bernoulli number <code>Bn</code>, using recurrence relation. Not work for large <code>n</code>.</p><p>Input :</p><ul><li><code>n</code> –- Serial number, <code>n &gt;= 2</code></li></ul><p>Output:</p><ul><li><code>BN(n)</code> –- Bn, n = 0..N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bernoulli_euler.jl#L36-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.bernob-Tuple{Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.bernob-Tuple{Int64}"><code>PureSpecial.Specfun.bernob</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Bernoulli number <code>Bn</code>, using series expression (DLMF 24.8.1).</p><p>Input :</p><ul><li><code>n</code> –- Serial number, <code>n &gt;= 2</code></li></ul><p>Output:</p><ul><li><code>BN(n)</code> –- Bn, n = 0..N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bernoulli_euler.jl#L82-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.beta-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.beta-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.beta</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute beta function <code>B(p, q)</code>.</p><p>Input :</p><ul><li><code>p</code>  –- Parameter  ( <code>p &gt; 0</code> )</li><li><code>q</code>  –- Parameter  ( <code>q &gt; 0</code> )</li></ul><p>Output:</p><ul><li><code>B(p, q)</code></li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing <code>Γ(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L352-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.bjndd-Tuple{Float64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.bjndd-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.bjndd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bjndd(x::Float64, n::Int)</code></pre><p>Compute Bessel functions Jn(x) and their first and second derivatives ( 0 &lt;= n &lt;= 100 )</p><p><strong>Input</strong></p><ul><li><code>x</code> –-  Argument of Jn(x)  ( x ≥ 0 )</li><li><code>n</code> –-  Order of Jn(x)</li></ul><p><strong>Output</strong></p><ul><li><code>BJ(n+1)</code> –-  Jn(x)</li><li><code>DJ(n+1)</code> –-  Jn&#39;(x)</li><li><code>FJ(n+1)</code> –-  Jn&quot;(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L16-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cchg-Tuple{Float64, Float64, ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cchg-Tuple{Float64, Float64, ComplexF64}"><code>PureSpecial.Specfun.cchg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cchg(a::Float64, b::Float64, z::Complex{Float64})</code></pre><p>Compute confluent hypergeometric function <code>M(a, b, z)</code> with real parameters <code>a</code>, <code>b</code> and a complex argument <code>z</code>.</p><p><strong>Input</strong></p><ul><li><code>a</code> –- Parameter</li><li><code>b</code> –- Parameter</li><li><code>z</code> –- Complex argument</li></ul><p><strong>Output</strong></p><ul><li>M(a,b,z)</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><code>Specfun.cgama</code></a> for computing complex ln[Г(x)]</li></ul><p><strong>Reference</strong></p><ul><li><a href="https://dlmf.nist.gov/13">DLMF C13: Confluent Hypergeometric Functions</a></li><li>Zhang, S.J., &amp; Jin, J.M. (1996). Computation of Special Functions. Wiley.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L18-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cerf-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cerf-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cerf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute complex Error function erf(z) &amp; erf&#39;(z)</p><p>Input</p><ul><li><code>z</code>   –- Complex argument of erf(z)</li></ul><p>Output: <code>(cer, cder)</code></p><ul><li>CER –- erf(z)</li><li>CDER –- erf&#39;(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L116-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cerzo-Tuple{Vector{ComplexF64}, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cerzo-Tuple{Vector{ComplexF64}, Int64}"><code>PureSpecial.Specfun.cerzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Evaluate the complex zeros of error function erf(z) using the modified Newton&#39;s iteration method</p><p>Input :</p><ul><li><code>NT</code> –- Total number of zeros</li></ul><p>Output:</p><ul><li><code>ZO(L)</code> –- L-th zero of erf(z), L=1,2,...,NT</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.cerf-Tuple{ComplexF64}"><code>Specfun.cerf</code></a> for computing erf(z) and erf&#39;(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L203-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cfc-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cfc-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cfc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute complex Fresnel integral C(z) and C&#39;(z)</p><p>Input</p><ul><li><code>z</code> –- Argument of C(z)</li></ul><p>Output: <code>(zf, zd)</code></p><ul><li>C(z)</li><li>C&#39;(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L261-L270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cfs-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cfs-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cfs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute complex Fresnel Integral S(z) and S&#39;(z)</p><p>Input</p><ul><li><code>z</code>  –- Argument of S(z)</li></ul><p>Output: <code>(zf, zd)</code></p><ul><li>S(z)</li><li>S&#39;(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L368-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><code>PureSpecial.Specfun.cgama</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cgama(z::Complex{Float64}, kf::Int)</code></pre><p>Compute complex gamma function <code>ln[Г(z)]</code> or <code>Г(z)</code>.</p><p>Input</p><ul><li><code>z</code>  –- Complex argument</li><li><code>kf</code> –- Function code<ul><li><code>kf=1</code> for <code>Г(z)</code></li><li><code>kf=0</code> for <code>ln[Г(z)]</code></li></ul></li></ul><p>Output</p><ul><li><code>ln[Г(z)]</code> or <code>Г(z)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L249-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgm-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgm-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgm(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute confluent hypergeometric function <code>M(a, b, x)</code>.</p><p>Input</p><ul><li><code>a</code>  –- Parameter</li><li><code>b</code>  –- Parameter ( b != 0,-1,-2,... )</li><li><code>x</code>  –- Argument</li></ul><p>Output</p><ul><li>M(a,b,x)</li></ul><p>Routine called</p><ul><li><a href="#PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><code>Specfun.cgama</code></a> for computing complex ln[Г(x)]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L215-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgm_kernel-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgm_kernel-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgm_kernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgm_kernel(a::Float64, b::Float64, x::Float64)</code></pre><p>F77 impl in scipy, without input check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L283-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgu-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgu-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgu</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgu(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute the confluent hypergeometric function <code>U(a, b, x)</code>.</p><p>Input:</p><ul><li><code>a</code>  –- Parameter</li><li><code>b</code>  –- Parameter</li><li><code>x</code>  –- Argument  ( x &gt; 0 )</li></ul><p>Output: <code>(hu, md, isfer)</code></p><ul><li><code>HU</code> –- U(a,b,x)</li><li><code>MD</code> –- Method code</li><li><code>ISFER</code> –- Error flag</li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.chgus-Tuple{Float64, Float64, Float64}"><code>Specfun.chgus</code></a> for small x ( MD=1 )</li><li><a href="#PureSpecial.Specfun.chgul-Tuple{Float64, Float64, Float64}"><code>Specfun.chgul</code></a> for large x ( MD=2 )</li><li><a href="#PureSpecial.Specfun.chgubi-Tuple{Float64, Float64, Float64}"><code>Specfun.chgubi</code></a> for integer b ( MD=3 )</li><li><a href="#PureSpecial.Specfun.chguit-Tuple{Float64, Float64, Float64}"><code>Specfun.chguit</code></a> for numerical integration ( MD=4 )</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L769-L789">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgubi-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgubi-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgubi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgubi(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute confluent hypergeometric function <code>U(a, b, x)</code> with integer <code>b</code> ( b = ±1,±2,... ).</p><p>Input:</p><ul><li><code>a</code>  –- Parameter</li><li><code>b</code>  –- Parameter</li><li><code>x</code>  –- Argument</li></ul><p>Output: <code>(hu, id)</code></p><ul><li><code>HU</code> –- U(a,b,x)</li><li><code>ID</code> –- Estimated number of significant digits</li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing gamma function Г(x)</li><li><a href="#PureSpecial.Specfun.psi-Tuple{T} where T&lt;:AbstractFloat"><code>Specfun.psi</code></a> for computing psi function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L508-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chguit-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chguit-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chguit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chguit(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute hypergeometric function <code>U(a, b, x)</code> by using Gaussian-Legendre integration (<code>n = 60</code>).</p><p>Input:</p><ul><li><code>a</code>  –- Parameter ( a &gt; 0 )</li><li><code>b</code>  –- Parameter</li><li><code>x</code>  –- Argument ( x &gt; 0 )</li></ul><p>Output: <code>(hu, id)</code></p><ul><li><code>HU</code> –- U(a,b,z)</li><li><code>ID</code> –- Estimated number of significant digits</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L679-L696">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgul-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgul-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgul</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgul(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute the confluent hypergeometric function <code>U(a, b, x)</code> for large argument <code>x</code>.</p><p>Input:</p><ul><li><code>a</code>  –- Parameter</li><li><code>b</code>  –- Parameter</li><li><code>x</code>  –- Argument, x &gt; 0</li></ul><p>Output: <code>(hu, id)</code></p><ul><li><code>HU</code> –- U(a,b,x)</li><li><code>ID</code> –- Estimated number of significant digits</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L392-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.chgus-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.chgus-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.chgus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chgus(a::Float64, b::Float64, x::Float64)</code></pre><p>Compute confluent hypergeometric function <code>U(a, b, x)</code> for small argument <code>x</code>.</p><p>Input:</p><ul><li><code>a</code>  –- Parameter</li><li><code>b</code>  –- Parameter ( b ≠ 0, -1, -2, ...)</li><li><code>x</code>  –- Argument</li></ul><p>Output: <code>(hu, id)</code></p><ul><li><code>HU</code> –- U(a,b,x)</li><li><code>ID</code> –- Estimated number of significant digits</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing gamma function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/hyper.jl#L455-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cisia-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cisia-Tuple{Float64}"><code>PureSpecial.Specfun.cisia</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cisia(x::Float64)</code></pre><p>Compute cosine and sine integrals <code>Ci(x)</code> and <code>Si(x)</code>.</p><p>Parameters:</p><ul><li><code>x</code>: Argument of <code>Ci(x)</code> and <code>Si(x)</code>, <code>x ≥ 0</code></li></ul><p>Returns: <code>(ci, si)</code></p><ul><li><code>Ci(x)</code></li><li><code>Si(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/trig_int.jl#L9-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cisib-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cisib-Tuple{Float64}"><code>PureSpecial.Specfun.cisib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cisib(x::Float64)</code></pre><p>Compute cosine and sine integrals <code>Ci(x)</code> and <code>Si(x)</code>, using polynomial and rational approximations:</p><ul><li><code>x &lt;= 1</code>,         <code>|eps(x)| &lt;= 1e-7</code></li><li><code>1 &lt; x &lt;= Inf</code>,   <code>|eps_ci(x)| &lt;= 5e-7, |eps_si(x)| &lt;= 3e-7</code></li></ul><p>Parameters:</p><ul><li><code>x</code>: Argument of <code>Ci(x)</code> and <code>Si(x)</code>, <code>x ≥ 0</code></li></ul><p>Returns: <code>(ci, si)</code></p><ul><li><code>Ci(x)</code></li><li><code>Si(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/trig_int.jl#L119-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cpbdn-Tuple{Int64, ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cpbdn-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpbdn</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the parabolic cylinder functions Dn(z) and Dn&#39;(z) for a complex argument.</p><p>Input:</p><ul><li><code>z</code> –- Complex argument of Dn(z)</li><li><code>n</code> –- Order of Dn(z)  ( n=0, ±1, ±2, … )</li></ul><p>Output: <code>(cpb, cpd)</code></p><ul><li><code>CPB(|n|)</code> –- Dn(z)</li><li><code>CPD(|n|)</code> –- Dn&#39;(z)</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.cpdsa-Tuple{Int64, ComplexF64}"><code>Specfun.cpdsa</code></a> for computing Dn(z) for a small |z|</li><li><a href="#PureSpecial.Specfun.cpdla-Tuple{Int64, ComplexF64}"><code>Specfun.cpdla</code></a> for computing Dn(z) for a large |z|</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L685-L700">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cpdla-Tuple{Int64, ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cpdla-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpdla</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute complex parabolic cylinder function Dn(z) for large argument.</p><p>Input:</p><ul><li><code>z</code>   –- Complex argument of Dn(z), Re(z) &gt; 0, |z| &gt;&gt; n, z -&gt; +Inf </li><li><code>n</code>   –- Order of Dn(z) (n = 0, ±1, ±2,…)</li></ul><p>Output:</p><ul><li><code>cdn</code> –- Dn(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L599-L609">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cpdsa-Tuple{Int64, ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cpdsa-Tuple{Int64, ComplexF64}"><code>PureSpecial.Specfun.cpdsa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute complex parabolic cylinder function Dn(z) for small argument.</p><p>Input:</p><ul><li><code>z</code>   –- Complex argument of Dn(z), Re(z) &lt;= 7</li><li><code>n</code>   –- Order of Dn(z) (n = 0, -1, -2,…)</li></ul><p>Output:</p><ul><li><code>cdn</code> –- Dn(z)</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.gaih-Tuple{Float64}"><code>Specfun.gaih</code></a> for computing Г(x), x = n/2 (n = 1, 2, ...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L627-L640">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.cpsi-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.cpsi-Tuple{ComplexF64}"><code>PureSpecial.Specfun.cpsi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cpsi(z::ComplexF64)</code></pre><p>Compute complex psi function <code>Ψ(z)</code> (Digamma Function).</p><p>Input :</p><ul><li><code>z</code></li></ul><p>Output:</p><ul><li><code>psi(z)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L573-L583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.djn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.djn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.djn_zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">djn_zeros(rj1::Vector{Float64}, n::Int64, nt::Int64)</code></pre><p>Compute zeros of integer-order Bessel function Jn(x) and its derivatives Jn&#39;(x)</p><p><strong>Input</strong></p><ul><li>n  –- Order of Bessel functions  (n &gt;= 0)</li><li>NT –- Number of zeros (roots)</li></ul><p><strong>Output</strong></p><ul><li>RJ0(L) –- L-th zero of Jn(x), L=1,2,...,NT</li><li>RJ1(L) –- L-th zero of Jn&#39;(x), L=1,2,...,NT</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>Specfun.jyndd</code></a> for computing Jn(x), and   its first and second derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L660-L677">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.dvla-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.dvla-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.dvla</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder functions Dv(x) for large argument</p><p>Input</p><ul><li><code>x</code>  –- Argument</li><li><code>va</code> –- Order</li></ul><p>Output</p><ul><li>Dv(x)</li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.vvla-Tuple{Float64, Float64}"><code>Specfun.vvla</code></a> for computing Vv(x) for large |x|</li><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L171-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.dvsa-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.dvsa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.dvsa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder function Dv(x) for small argument</p><p>Input</p><ul><li><code>x</code>  –- Argument</li><li><code>va</code> –- Order</li></ul><p>Output</p><ul><li>Dv(x)</li></ul><p>Routine called</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L214-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.dyn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.dyn_zeros-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.dyn_zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dyn_zeros(ry1::Vector{Float64}, n::Int64, nt::Int64)</code></pre><p>Compute zeros of integer-order Bessel function Yn(x) and its derivatives Yn&#39;(x)</p><p><strong>Input</strong></p><ul><li>n  –- Order of Bessel functions  (n &gt;= 0)</li><li>NT –- Number of zeros (roots)</li></ul><p><strong>Output</strong></p><ul><li>RY0(L) –- L-th zero of Yn(x), L=1,2,...,NT</li><li>RY1(L) –- L-th zero of Yn&#39;(x), L=1,2,...,NT</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>Specfun.jyndd</code></a> for computing Yn(x), and   its first and second derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L792-L809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.e1xa-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.e1xa-Tuple{Float64}"><code>PureSpecial.Specfun.e1xa</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">e1xa(x::Float64)</code></pre><p>Compute exponential integral <code>E1(x)</code>, using rational approximation:</p><ul><li><code>0 &lt; x &lt;= 1</code>:   <code>|eps(x)| &lt;= 2e10-7</code></li><li><code>1 &lt; x</code>:        <code>|eps(x)| &lt;= 2e10-8</code></li></ul><p>Input:</p><ul><li><code>x</code>: Argument of E1(x), ( <code>x &gt; 0</code> )</li></ul><p>Output:</p><ul><li><code>E1(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L14-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.e1xb-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.e1xb-Tuple{Float64}"><code>PureSpecial.Specfun.e1xb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">e1xb(x::Float64)</code></pre><p>Compute exponential integral <code>E1(x)</code>.</p><p>Input</p><ul><li><code>x</code>: Argument of E1(x), ( <code>x &gt; 0</code> )</li></ul><p>Output</p><ul><li><code>E1(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L48-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.e1z-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.e1z-Tuple{ComplexF64}"><code>PureSpecial.Specfun.e1z</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">e1z(z::Complex{Float64})</code></pre><p>Compute complex exponential integral <code>E1(z)</code>.</p><p>Input</p><ul><li><code>z</code>: Argument of <code>E1(z)</code></li></ul><p>Output</p><ul><li><code>E1(z)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L96-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.eix-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.eix-Tuple{Float64}"><code>PureSpecial.Specfun.eix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eix(x::Float64)</code></pre><p>Compute exponential integral <code>Ei(x)</code>.</p><p>Input</p><ul><li><code>x</code>: Argument of <code>Ei(x)</code></li></ul><p>Output</p><ul><li><code>Ei(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L287-L297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.eixz-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.eixz-Tuple{ComplexF64}"><code>PureSpecial.Specfun.eixz</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eixz(z::Complex{Float64})</code></pre><p>Compute complex exponential integral <code>Ei(z)</code>.</p><p>Input</p><ul><li><code>x</code>: Complex argument of <code>Ei(z)</code></li></ul><p>Output</p><ul><li><code>Ei(z)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L337-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.envj-Tuple{Any, Any}"><a class="docstring-binding" href="#PureSpecial.Specfun.envj-Tuple{Any, Any}"><code>PureSpecial.Specfun.envj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">envj(n, x)</code></pre><p>Helper function used in <code>msta1</code>, <code>msta2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L271-L275">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.enxa-Tuple{Int64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.enxa-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.enxa</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enxa(n::Int, x::Float64)</code></pre><p>Compute exponential integral <code>En(x)</code>, using forward recurrence.</p><ul><li><code>0 &lt; x &lt;= 20</code>:   <code>|eps(x)| &lt;= 1e-8</code></li></ul><p>Parameters:</p><ul><li><code>n</code> : Order of En(x), <code>n &gt;= 1</code></li><li><code>x</code> : Argument of En(x), ( <code>0 &lt; x &lt;= 20</code> )</li></ul><p>Returns:</p><ul><li><code>[ En(x) for n in 0:n ] :: Vector{Float64}</code></li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.e1xb-Tuple{Float64}"><code>Specfun.e1xb</code></a> for computing <code>E1(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L175-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.enxb-Tuple{Int64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.enxb-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.enxb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enxb(n::Int, x::Float64)</code></pre><p>Compute exponential integral <code>En(x)</code>.</p><p>Parameters:</p><ul><li><code>n</code>: Order of En(x), <code>n &gt;= 1</code></li><li><code>x</code>: Argument of En(x), ( <code>x &gt;= 0</code> )</li></ul><p>Returns:</p><ul><li><code>[ En(x) for n in 0:n ] :: Vector{Float64}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/exp.jl#L210-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.erf-Tuple{ComplexF64}"><a class="docstring-binding" href="#PureSpecial.Specfun.erf-Tuple{ComplexF64}"><code>PureSpecial.Specfun.erf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute error function erf(z) for a complex argument (z=x+iy)</p><p>Input:</p><ul><li><code>z</code>   –- Complex argument</li></ul><p>Output:</p><ul><li>erf(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L54-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.erf-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.erf-Tuple{Float64}"><code>PureSpecial.Specfun.erf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute error function erf(x)</p><p>Input:</p><ul><li><code>x</code>   –- Argument of erf(x)</li></ul><p>Output:</p><ul><li>erf(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L11-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.eulera-Tuple{Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.eulera-Tuple{Int64}"><code>PureSpecial.Specfun.eulera</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Euler number <code>En</code>, using recurrence relation. Not work for large <code>n</code>.</p><p>Input :</p><ul><li><code>n</code> –- Serial number, <code>n &gt;= 2</code></li></ul><p>Output:</p><ul><li><code>EN(n)</code> –- En, n = 0..N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bernoulli_euler.jl#L119-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.eulerb-Tuple{Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.eulerb-Tuple{Int64}"><code>PureSpecial.Specfun.eulerb</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Euler number <code>En</code>, using series expression (DLMF 24.8.4).</p><p>Input :</p><ul><li><code>n</code> –- Serial number, <code>n &gt;= 2</code></li></ul><p>Output:</p><ul><li><code>EN(n)</code> –- En, n = 0..N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bernoulli_euler.jl#L164-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.fcs-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.fcs-Tuple{Float64}"><code>PureSpecial.Specfun.fcs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Fresnel integrals C(x) and S(x)</p><p>Input</p><ul><li><code>x</code> –- Argument of C(x) and S(x)</li></ul><p>Output <code>(c, s)</code></p><ul><li>C(x)</li><li>S(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L475-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.fcszo-Tuple{Vector{ComplexF64}, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.fcszo-Tuple{Vector{ComplexF64}, Int64, Int64}"><code>PureSpecial.Specfun.fcszo</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the complex zeros of Fresnel integral C(z) or S(z) using modified Newton&#39;s iteration method</p><p>Input</p><ul><li><code>KF</code>  –- Function code<ul><li><code>KF=1</code> for C(z)</li><li><code>KF=2</code> for S(z)</li></ul></li><li><code>NT</code>  –- Total number of zeros</li></ul><p>Output</p><ul><li><code>ZO(L)</code> –- L-th zero of C(z) or S(z)</li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.cfc-Tuple{ComplexF64}"><code>Specfun.cfc</code></a> for computing Fresnel integral C(z)</li><li><a href="#PureSpecial.Specfun.cfs-Tuple{ComplexF64}"><code>Specfun.cfs</code></a> for computing Fresnel integral S(z)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L564-L580">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.ffk-Tuple{Int64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.ffk-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.ffk</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute modified Fresnel integrals F±(x) and K±(x)</p><p>Input</p><ul><li>x   –- Argument of F±(x) and K±(x)</li><li>KS  –- Sign code   KS=0 for calculating F+(x) and K+(x)   KS=1 for calculating F<em>(x) and K</em>(x)</li></ul><p>Output</p><ul><li>FR  –- Re[F±(x)]</li><li>FI  –- Im[F±(x)]</li><li>FM  –- |F±(x)|</li><li>FA  –- Arg[F±(x)], Degs.</li><li>GR  –- Re[K±(x)]</li><li>GI  –- Im[K±(x)]</li><li>GM  –- |K±(x)|</li><li>GA  –- Arg[K±(x)], Degs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/error.jl#L648-L667">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.gaih-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.gaih-Tuple{Float64}"><code>PureSpecial.Specfun.gaih</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gaih(x::Float64)</code></pre><p>Compute gamma function Г(x)</p><p>Input x  –- Argument of Г(x), x = n/2, n=1,2,3,…</p><p>Output ga –- Г(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L214-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.gam0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.gam0-Tuple{Float64}"><code>PureSpecial.Specfun.gam0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gam0(x)</code></pre><p>Compute gamma function Г(x) for small <code>x</code></p><p>Input x  –- Argument of Г(x)  ( |x| ≤ 1 )</p><p>Output ga –- Г(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L53-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.gamma2-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>PureSpecial.Specfun.gamma2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gamma2(x::Float64)</code></pre><p>Compute gamma function <code>Г(x)</code>.</p><p>Input</p><ul><li><code>x</code>  –- Argument of Г(x)       ( x is not equal to 0,-1,-2,… )</li></ul><p>Output</p><ul><li>Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L81-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.incob-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.incob-Tuple{Float64, Float64, Float64}"><code>PureSpecial.Specfun.incob</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute incomplete beta function <code>Ix(a,b)</code>.</p><p>Input :</p><ul><li><code>a</code> –- Parameter</li><li><code>b</code> –- Parameter</li><li><code>x</code> –- Argument ( <code>0 ≤ x ≤ 1</code> )</li></ul><p>Output:</p><ul><li><code>BIX</code> –- <code>Ix(a,b)</code></li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.beta-Tuple{Float64, Float64}"><code>Specfun.beta</code></a> for computing beta function <code>B(p,q)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L442-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.incog-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.incog-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.incog</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute incomplete gamma function <code>γ(a,x)</code>, <code>Γ(a,x)</code> and <code>P(a,x)</code>.</p><p>Input :</p><ul><li><code>a</code>   –- Parameter ( a ≤ 170 )</li><li><code>x</code>   –- Argument</li></ul><p>Output: <code>(gin, gim, gip, isfer)</code>:</p><ul><li><code>gin</code> –- γ(a,x), incomplete gamma function</li><li><code>gim</code> –- Γ(a,x), incomplete gamma function</li><li><code>gip</code> –- P(a,x), normalized incomplete gamma function</li><li><code>isfer</code> –- Error flag, <code>isfer &gt; 0</code> when error occurs</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L380-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.itairy-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.itairy-Tuple{Float64}"><code>PureSpecial.Specfun.itairy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">itairy(x::Float64)</code></pre><p>Compute the integrals of Airy functions with respect to t from 0 and x ( x ≥ 0 )</p><p><strong>Input</strong></p><ul><li><code>x</code>   –- Upper limit of the integral</li></ul><p><strong>Output</strong></p><ul><li><code>apt</code> –- Integration of Ai(t) from 0 and x</li><li><code>bpt</code> –- Integration of Bi(t) from 0 and x</li><li><code>ant</code> –- Integration of Ai(-t) from 0 and x</li><li><code>bnt</code> –- Integration of Bi(-t) from 0 and x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/airy.jl#L391-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.itsh0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.itsh0-Tuple{Float64}"><code>PureSpecial.Specfun.itsh0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Evaluate the integral of Struve function H0(t) with respect to t from 0 and x</p><p>Input :</p><ul><li>x   –- Upper limit  ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>TH0 –- Integration of H0(t) from 0 and x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L309-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.itsl0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.itsl0-Tuple{Float64}"><code>PureSpecial.Specfun.itsl0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Evaluate the integral of modified Struve function L0(t) with respect to t from 0 to x</p><p>Input :</p><ul><li>x   –- Upper limit  ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>TL0 –- Integration of L0(t) from 0 to x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L445-L454">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.itth0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.itth0-Tuple{Float64}"><code>PureSpecial.Specfun.itth0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Evaluate the integral H0(t)/t with respect to t from x to infinity</p><p>Input :</p><ul><li>x   –- Lower limit  ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>TTH –- Integration of H0(t)/t from x to infinity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L390-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jdzo-Tuple{Int64, Vector{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#PureSpecial.Specfun.jdzo-Tuple{Int64, Vector{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>PureSpecial.Specfun.jdzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jdzo(
    nt::Int,
    zo::Vector{Float64}, n::Vector{Int}, m::Vector{Int}, p::Vector{Int}
)</code></pre><p>Compute the zeros of Bessel functions Jn(x) and Jn&#39;(x), and arrange them in the order of their magnitudes.</p><p><strong>Input</strong></p><ul><li><code>NT</code>    –- Number of total zeros ( NT ≤ 1200 )</li></ul><p><strong>Output</strong></p><ul><li><code>ZO(L)</code> –- Value of the L-th zero of Jn(x)         and Jn&#39;(x)</li><li><code>N(L)</code>  –- n, order of Jn(x) or Jn&#39;(x) associated         with the L-th zero</li><li><code>M(L)</code>  –- m, serial number of the zeros of Jn(x)         or Jn&#39;(x) associated with the L-th zero         ( L is the serial number of all the           zeros of Jn(x) and Jn&#39;(x) )</li><li><code>P(L)</code>  –- 0 (TM) or 1 (TE), a code for designating the         zeros of Jn(x)  or Jn&#39;(x).         In the waveguide applications, the zeros         of Jn(x) correspond to TM modes and         those of Jn&#39;(x) correspond to TE modes</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.bjndd-Tuple{Float64, Int64}"><code>Specfun.bjndd</code></a> for computing Jn(x), Jn&#39;(x) and Jn&#39;&#39;(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L82-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jdzo-Tuple{Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.jdzo-Tuple{Int64}"><code>PureSpecial.Specfun.jdzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jdzo(nt::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L257-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.jn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.jn_zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jn_zeros(rj0::Vector{Float64}, n::Int64, nt::Int64)</code></pre><p>Compute zeros of integer-order Bessel functions Jn.</p><p><strong>Input</strong></p><ul><li><code>n</code>  –- Order of Bessel functions  (n &gt;= 0)</li><li><code>NT</code> –- Number of zeros (roots)</li></ul><p><strong>Output</strong></p><ul><li><code>RJ0(L)</code> –- L-th zero of Jn(x),  L=1,2,...,NT</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>Specfun.jyndd</code></a> for computing Jn(x), and   its first and second derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L588-L603">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jynbh-Tuple{Float64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PureSpecial.Specfun.jynbh-Tuple{Float64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.jynbh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jynbh(
    x::Float64, n::Int, nmin::Int,
    bj::Vector{Float64}, by::Vector{Float64}
)</code></pre><p>Compute Bessel functions Jn(x), Yn(x)</p><p>Input</p><ul><li><code>x</code> –- Argument of Jn(x) and Yn(x) ( x ≥ 0 )</li><li><code>n</code> –- Highest order of Jn(x) and Yn(x) computed  ( n ≥ 0 )</li><li><code>nmin</code> – Lowest order computed  ( nmin ≥ 0 )</li></ul><p>Output</p><ul><li><code>BJ(n-NMIN)</code> –- Jn(x)   ; if indexing starts at 0</li><li><code>BY(n-NMIN)</code> –- Yn(x)   ; if indexing starts at 0</li></ul><p>Return:</p><ul><li><code>NM</code> –- Highest order computed</li></ul><p>Routines called</p><ul><li><a href="#PureSpecial.Specfun.msta1-Tuple{Float64, Int64}"><code>Specfun.msta1</code></a> and <a href="#PureSpecial.Specfun.msta2-Tuple{Float64, Int64, Int64}"><code>Specfun.msta2</code></a>   to calculate the startingpoint for backward recurrence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L372-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.jyndd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jyndd(x::Float64, n::Int)</code></pre><p>compute bessel functions jn(x) and yn(x), and their first and second derivatives.</p><p>input</p><ul><li><code>x</code>   –-  argument of jn(x) and yn(x) ( x &gt; 0 )</li><li><code>n</code>   –-  order of jn(x) and yn(x)</li></ul><p>output</p><ul><li><code>bjn</code> –-  jn(x)</li><li><code>djn</code> –-  jn&#39;(x)</li><li><code>fjn</code> –-  jn&quot;(x)</li><li><code>byn</code> –-  yn(x)</li><li><code>dyn</code> –-  yn&#39;(x)</li><li><code>fyn</code> –-  yn&quot;(x)</li></ul><p>routines called</p><ul><li><a href="#PureSpecial.Specfun.jynbh-Tuple{Float64, Int64, Int64, Vector{Float64}, Vector{Float64}}"><code>Specfun.jynbh</code></a> to compute jn and yn</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L550-L570">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.jyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><a class="docstring-binding" href="#PureSpecial.Specfun.jyzo-Tuple{Int64, Int64, Vararg{Vector{Float64}, 4}}"><code>PureSpecial.Specfun.jyzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jyzo(
    n::Int64, nt::Int64,
    rj0::Vector{Float64}, rj1::Vector{Float64},
    ry0::Vector{Float64}, ry1::Vector{Float64}
)</code></pre><p>Compute the zeros of Bessel functions Jn(x), Yn(x), and their derivatives</p><p><strong>Input</strong></p><ul><li><code>n</code>  –- Order of Bessel functions  (n &gt;= 0)</li><li><code>NT</code> –- Number of zeros (roots)</li></ul><p><strong>Output</strong></p><ul><li><code>RJ0(L)</code> –- L-th zero of Jn(x),  L=1,2,...,NT</li><li><code>RJ1(L)</code> –- L-th zero of Jn&#39;(x), L=1,2,...,NT</li><li><code>RY0(L)</code> –- L-th zero of Yn(x),  L=1,2,...,NT</li><li><code>RY1(L)</code> –- L-th zero of Yn&#39;(x), L=1,2,...,NT</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>Specfun.jyndd</code></a> for computing Jn(x), Yn(x), and   their first and second derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L849-L872">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.klvna-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.klvna-Tuple{Float64}"><code>PureSpecial.Specfun.klvna</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">klvna(x::Float64)</code></pre><p>Compute Kelvin functions ber x, bei x, ker x and kei x, and their derivatives  ( x &gt; 0 )</p><p><strong>Input</strong></p><ul><li><code>x</code> –- Argument of Kelvin functions</li></ul><p><strong>Output</strong></p><ul><li><code>ber</code> –- ber x</li><li><code>bei</code> –- bei x</li><li><code>ger</code> –- ker x</li><li><code>gei</code> –- kei x</li><li><code>der</code> –- ber&#39;x</li><li><code>dei</code> –- bei&#39;x</li><li><code>her</code> –- ker&#39;x</li><li><code>hei</code> –- kei&#39;x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/kelvin.jl#L10-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.klvnb"><a class="docstring-binding" href="#PureSpecial.Specfun.klvnb"><code>PureSpecial.Specfun.klvnb</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Compute Kelvin functions and their derivatives using polynomial approximation.</p><p>Use <a href="#PureSpecial.Specfun.klvna-Tuple{Float64}"><code>Specfun.klvna</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/kelvin.jl#L212-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.klvnzo-Tuple{Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.klvnzo-Tuple{Int64, Int64}"><code>PureSpecial.Specfun.klvnzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">klvnzo(nt::Int, kd::Int)</code></pre><p>Compute the zeros of Kelvin functions.</p><p><strong>Input</strong></p><ul><li><code>NT</code>  –- Total number of zeros</li><li><code>KD</code>  –- Function code<ul><li>KD=1 to 8 for ber x, bei x, ker x, kei x,               ber&#39;x, bei&#39;x, ker&#39;x and kei&#39;x,               respectively.</li></ul></li></ul><p><strong>Output</strong></p><ul><li>ZO(M) –- the M-th zero of Kelvin function for code KD.</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.klvna-Tuple{Float64}"><code>Specfun.klvna</code></a> for computing Kelvin functions and their derivatives.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/kelvin.jl#L220-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.kmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.kmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.kmn</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the expansion coefficients of the prolate and oblate spheroidal functions and joining factors.</p><p>Input:</p><ul><li><code>df</code>, in, read-only</li></ul><p>Output:</p><ul><li><code>dn</code></li></ul><p>Return: <code>(ck1, ck2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L825-L837">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.lgama-Tuple{Int64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.lgama-Tuple{Int64, Float64}"><code>PureSpecial.Specfun.lgama</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lgama(kf::Int, x::Float64)</code></pre><p>Compute gamma function <code>ln[Γ(x)]</code> or <code>Γ(x)</code>.</p><p>Input:</p><ul><li><code>x</code>  –- Argument of Γ(x) ( x &gt; 0 )</li><li><code>kf</code> –- Function code<ul><li>kf=0 for <code>ln[Γ(x)]</code></li><li>kf=1 for <code>Γ(x)</code></li></ul></li></ul><p>Output:</p><ul><li><code>ln[Γ(x)]</code> or <code>Γ(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L161-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.lpmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PureSpecial.Specfun.lpmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.lpmns</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute associated Legendre functions Pmn(x) and Pmn&#39;(x) for a given order.</p><p>Input:</p><ul><li><code>m</code> –- Order of Pmn(x),  m = 0,1,2,...,n</li><li><code>n</code> –- Degree of Pmn(x), n = 0,1,2,...,N</li><li><code>x</code> –- Argument of Pmn(x)</li></ul><p>Output:</p><ul><li>Pmn(x)</li><li>Pmn&#39;(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/legendre.jl#L39-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.lpmv-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.lpmv-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.lpmv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the associated Legendre function Pmv(x) with an integer order and an arbitrary degree v, using recursion for large degrees.</p><p>Input:</p><ul><li><code>v</code>   –- Degree of Pmv(x)</li><li><code>m</code>   –- Order of Pmv(x)</li><li><code>x</code>   –- Argument of Pm(x), -1 ≤ x ≤ 1</li></ul><p>Output:</p><ul><li>Pmv(x)</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.lpmv0-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><code>lpmv0</code></a></li><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>gamma2</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/legendre.jl#L382-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.lpmv0-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.lpmv0-Union{Tuple{T}, Tuple{T, Int64, T}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.lpmv0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the associated Legendre function Pmv(x) with an integer order and an arbitrary nonnegative degree v.</p><p>Input:</p><ul><li><code>v</code>   –- Degree of Pmv(x),     v &gt;= 0</li><li><code>m</code>   –- Order of Pmv(x)</li><li><code>x</code>   –- Argument of Pm(x),    -1 ≤ x ≤ 1</li></ul><p>Output:</p><ul><li>Pmv(x)</li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.psi-Tuple{T} where T&lt;:AbstractFloat"><code>Specfun.psi</code></a> for computing Psi function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/legendre.jl#L263-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.lqmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PureSpecial.Specfun.lqmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>PureSpecial.Specfun.lqmns</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute associated Legendre functions Qmn(x) and Qmn&#39;(x) for a given order.</p><p>Input:</p><ul><li><code>m</code> –- Order of Qmn(x),  m = 0,1,2,...</li><li><code>n</code> –- Degree of Qmn(x), n = 1,2,...</li><li><code>x</code> –- Argument of Qmn(x)</li></ul><p>Output:</p><ul><li>Qmn(x)</li><li>Qmn&#39;(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/legendre.jl#L116-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.msta1-Tuple{Float64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.msta1-Tuple{Float64, Int64}"><code>PureSpecial.Specfun.msta1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">msta1(x::Float64, mp::Int)</code></pre><p>Determine the starting point for backward recurrence such that the magnitude of Jn(x) at that point is about 10^(-MP)</p><p>Input</p><ul><li><code>x</code>     –- Argument of Jn(x)</li><li><code>MP</code>    –- Value of magnitude</li></ul><p>Output</p><ul><li>Starting point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L280-L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.msta2-Tuple{Float64, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.msta2-Tuple{Float64, Int64, Int64}"><code>PureSpecial.Specfun.msta2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">msta2(x::Float64, n::Int64, mp::Int64)</code></pre><p>Determine the starting point for backward recurrence such that all Jn(x) has MP significant digits</p><p>Input</p><ul><li><code>x</code>  –- Argument of Jn(x)</li><li><code>n</code>  –- Order of Jn(x)</li><li><code>MP</code> –- Significant digit</li></ul><p>Output</p><ul><li>Starting point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L321-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.pbdv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.pbdv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>PureSpecial.Specfun.pbdv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder functions Dv(x) and their derivatives</p><p>Input</p><ul><li><code>x</code> –- Argument of Dv(x)</li><li><code>v</code> –- Order of Dv(x)</li></ul><p>Output</p><ul><li><code>DV(na)</code> –- Dn+v0(x)</li><li><code>DP(na)</code> –- Dn+v0&#39;(x)   ( na = |n|, v0 = v-n, |v0| &lt; 1,   n = 0,±1,±2,… )</li><li><code>(pdf, pdd)</code><ul><li>PDF –- Dv(x)</li><li>PDD –- Dv&#39;(x)</li></ul></li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.dvsa-Tuple{Float64, Float64}"><code>Specfun.dvsa</code></a> for computing Dv(x) for small |x|</li><li><a href="#PureSpecial.Specfun.dvla-Tuple{Float64, Float64}"><code>Specfun.dvla</code></a> for computing Dv(x) for large |x|</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L269-L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.pbvv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.pbvv-Tuple{Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>PureSpecial.Specfun.pbvv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder functions Vv(x) and their derivatives</p><p>Input</p><ul><li><code>x</code> –- Argument of Vv(x)</li><li><code>v</code> –- Order of Vv(x)</li></ul><p>Output</p><ul><li><code>VV(na)</code> –- Vv(x)</li><li><code>VP(na)</code> –- Vv&#39;(x)   ( na = |n|, v = n+v0, |v0| &lt; 1    n = 0,±1,±2,… )</li><li><code>(pvf, pvd)</code><ul><li><code>PVF</code> –- Vv(x)</li><li><code>PVD</code> –- Vv&#39;(x)</li></ul></li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.vvsa-Tuple{Float64, Float64}"><code>Specfun.vvsa</code></a> for computing Vv(x) for small |x|</li><li><a href="#PureSpecial.Specfun.vvla-Tuple{Float64, Float64}"><code>Specfun.vvla</code></a> for computing Vv(x) for large |x|</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L458-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.pbwa-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.pbwa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.pbwa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder functions W(a,±x) and their derivatives</p><p>Input</p><ul><li><code>a</code> –- Parameter  ( 0 ≤ |a| ≤ 5 )</li><li><code>x</code> –- Argument of W(a,±x)  ( 0 ≤ |x| ≤ 5 )</li></ul><p>Output</p><ul><li><code>(w1f, w1d, w2f, w2d)</code><ul><li><code>W1F</code> –- W(a,x)</li><li><code>W1D</code> –- W&#39;(a,x)</li><li><code>W2F</code> –- W(a,-x)</li><li><code>W2D</code> –- W&#39;(a,-x)</li></ul></li></ul><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.cgama-Tuple{ComplexF64, Int64}"><code>Specfun.cgama</code></a> for computing complex gamma function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L18-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.psi-Tuple{T} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.psi-Tuple{T} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.psi</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Psi function <code>Ψ(x)</code> (Digamma Function).</p><p>Input:</p><ul><li><code>x</code>  –- Argument of <code>psi(x)</code></li></ul><p>Output:</p><ul><li><code>psi(x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/gamma.jl#L508-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.rmn1-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.rmn1-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rmn1</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute prolate and oblate spheroidal radial functions of the first kind for given m, n, c, and x</p><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.sckb-Union{Tuple{T}, Tuple{Int64, Int64, T, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.sckb</code></a></li><li><a href="#PureSpecial.Specfun.sphj-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>Specfun.sphj</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L542-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.rmn2l-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.rmn2l-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rmn2l</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute prolate and oblate spheroidal radial functions of the second kind for given m, n, c and a large cx</p><p>Routine called:</p><ul><li><a href="#PureSpecial.Specfun.sphy-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>Specfun.sphy</code></a> for computing the spherical Bessel</li></ul><p>functions of the second kind</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L726-L734">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.rmn2sp-NTuple{7, Any}"><a class="docstring-binding" href="#PureSpecial.Specfun.rmn2sp-NTuple{7, Any}"><code>PureSpecial.Specfun.rmn2sp</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute prolate spheroidal radial function of the second kind with a small argument</p><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.kmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.kmn</code></a> for computing expansion coefficients and joining factors</li><li><a href="#PureSpecial.Specfun.lpmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>Specfun.lpmns</code></a> for computing the associated Legendre functions of the first kind</li><li><a href="#PureSpecial.Specfun.lqmns-Tuple{Int64, Int64, Float64, Vector{Float64}, Vector{Float64}}"><code>Specfun.lqmns</code></a> for computing the associated Legendre functions of the second kind</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L842-L849">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.rswfp-Union{Tuple{T}, Tuple{Int64, Int64, T, T, T, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.rswfp-Union{Tuple{T}, Tuple{Int64, Int64, T, T, T, Int64}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.rswfp</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute prolate spheriodal radial functions of the first and second kinds, and their derivatives</p><p>Input:   m  –- Mode parameter, m = 0,1,2,... n  –- Mode parameter, n = m,m+1,m+2,... c  –- Spheroidal parameter x  –- Argument of radial function ( x &gt; 1.0 ) cv –- Characteristic value KF –- Function code     KF=1 for the first kind     KF=2 for the second kind     KF=3 for both the first and second kinds</p><p>Output:   R1F –- Radial function of the first kind R1D –- Derivative of the radial function of         the first kind R2F –- Radial function of the second kind R2D –- Derivative of the radial function of         the second kind</p><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.sdmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.sdmn</code></a></li><li><a href="#PureSpecial.Specfun.rmn1-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.rmn1</code></a></li><li><a href="#PureSpecial.Specfun.rmn2l-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>Specfun.rmn2l</code></a></li><li>rmn2sp</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L854-L882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.sckb-Union{Tuple{T}, Tuple{Int64, Int64, T, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.sckb-Union{Tuple{T}, Tuple{Int64, Int64, T, Vector{T}, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sckb</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the expansion coefficients of the prolate and oblate spheroidal functions</p><p>Input:</p><ul><li><code>m</code>  –- Mode parameter</li><li>`n  –- Mode parameter</li><li><code>c</code>  –- Spheroidal parameter</li><li><code>DF(k)</code> –- Expansion coefficients dk</li></ul><p>Output:  </p><ul><li><code>CK(k)</code> –- Expansion coefficients ck;   CK(1), CK(2), ... correspond to   c0, c2, ...</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L321-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.sdmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.sdmn-Union{Tuple{T}, Tuple{Int64, Int64, T, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sdmn</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the expansion coefficients of the prolate and oblate spheroidal functions, dk</p><p>Input: </p><ul><li><code>m</code>  –- Mode parameter</li><li><code>n</code>  –- Mode parameter</li><li><code>c</code>  –- Spheroidal parameter</li><li><code>cv</code> –- Characteristic value</li><li><code>KD</code> –- Function code<ul><li><code>KD= 1</code> for prolate;</li><li><code>KD=-1</code> for oblate</li></ul></li></ul><p>Output: </p><ul><li><code>DF(k)</code> –- Expansion coefficients dk;   DF(1), DF(2), ... correspond to   d0, d2, ... for even n-m and d1,   d3, ... for odd n-m</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L169-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.segv-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.segv-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.segv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute the characteristic values of spheroidal wave functions</p><p>Input:  </p><ul><li>m  –- Mode parameter</li><li>n  –- Mode parameter</li><li>c  –- Spheroidal parameter</li><li>KD –- Function code<ul><li>KD=1 for Prolate;</li><li>KD=-1 for Oblate</li></ul></li></ul><p>Output:  </p><ul><li>CV –- Characteristic value for given m, n and c</li><li>EG(L) –- Characteristic value for mode m and n&#39;       ( L = n&#39; - m + 1 )</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L28-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.sphj-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.sphj-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sphj</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute spherical Bessel functions jn(x) and their derivatives</p><p>Input:   x –- Argument of jn(x) n –- Order of jn(x)  ( n = 0,1,… )</p><p>Output:   sj –- Array of jn(x) values dj –- Array of jn&#39;(x) values nm –- Highest order computed</p><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.msta1-Tuple{Float64, Int64}"><code>Specfun.msta1</code></a></li><li><a href="#PureSpecial.Specfun.msta2-Tuple{Float64, Int64, Int64}"><code>Specfun.msta2</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L464-L480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.sphy-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#PureSpecial.Specfun.sphy-Union{Tuple{T}, Tuple{Int64, T, Vector{Float64}, Vector{Float64}}} where T&lt;:AbstractFloat"><code>PureSpecial.Specfun.sphy</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute spherical Bessel functions yn(x) and their derivatives</p><p>Input :  </p><ul><li>x –- Argument of yn(x) ( x ≥ 0 )</li><li>n –- Order of yn(x) ( n = 0,1,… )</li></ul><p>Output:  </p><ul><li><code>SY(n)</code> –- yn(x)</li><li><code>DY(n)</code> –- yn&#39;(x)</li><li><code>NM</code> –- Highest order computed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/spheroidal.jl#L670-L682">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.stvh0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.stvh0-Tuple{Float64}"><code>PureSpecial.Specfun.stvh0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Struve Function H0(x)</p><p>Input:</p><ul><li><code>x</code>   –- Argument of H0(x) ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>H0(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L18-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.stvh1-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.stvh1-Tuple{Float64}"><code>PureSpecial.Specfun.stvh1</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Struve Function H1(x)</p><p>Input:</p><ul><li><code>x</code>   –- Argument of H1(x) ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>H1(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L75-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.stvhv-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.stvhv-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.stvhv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Struve Functions Hv(x) with arbitrary order v  ( -8.0 ≤ v ≤ 12.5 )</p><p>Input  :</p><ul><li><code>v</code>  –- Order of Hv(x)</li><li><code>x</code>  –- Argument of Hv(x) ( x ≥ 0 )</li></ul><p>Output :</p><ul><li>Hv(x)</li></ul><p>Required:</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> function to compute the Gamma function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L132-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.stvl0-Tuple{Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.stvl0-Tuple{Float64}"><code>PureSpecial.Specfun.stvl0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Modified Struve Function L0(x)</p><p>Input:</p><ul><li>x   –- Argument of L0(x)  ( x ≥ 0 )</li></ul><p>Output:</p><ul><li>SL0 –- L0(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/struve.jl#L251-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.vvla-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.vvla-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.vvla</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder function Vv(x) for large argument</p><p>Input</p><ul><li><code>x</code>  –- Argument</li><li><code>va</code> –- Order</li></ul><p>Output</p><ul><li>Vv(x)</li></ul><p>Routines called:</p><ul><li><a href="#PureSpecial.Specfun.dvla-Tuple{Float64, Float64}"><code>Specfun.dvla</code></a> for computing Dv(x) for large |x|</li><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L127-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.vvsa-Tuple{Float64, Float64}"><a class="docstring-binding" href="#PureSpecial.Specfun.vvsa-Tuple{Float64, Float64}"><code>PureSpecial.Specfun.vvsa</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute parabolic cylinder function Vv(x) for small argument</p><p>Input</p><ul><li><code>x</code>  –- Argument</li><li><code>va</code> –- Order</li></ul><p>Output</p><ul><li>Vv(x)</li></ul><p>Routine called</p><ul><li><a href="#PureSpecial.Specfun.gamma2-Tuple{Float64}"><code>Specfun.gamma2</code></a> for computing Г(x)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/parabolic.jl#L402-L415">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PureSpecial.Specfun.yn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><a class="docstring-binding" href="#PureSpecial.Specfun.yn_zeros-Tuple{Vector{Float64}, Int64, Int64}"><code>PureSpecial.Specfun.yn_zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">yn_zeros(ry0::Vector{Float64}, n::Int64, nt::Int64)</code></pre><p>Compute zeros of integer-order Bessel function Yn(x).</p><p><strong>Input</strong></p><ul><li>n  –- Order of Bessel functions  (n &gt;= 0)</li><li>NT –- Number of zeros (roots)</li></ul><p><strong>Output</strong></p><ul><li>RY0(L) –- L-th zero of Yn(x),  L=1,2,...,NT</li></ul><p><strong>Routine called</strong></p><ul><li><a href="#PureSpecial.Specfun.jyndd-Tuple{Float64, Int64}"><code>Specfun.jyndd</code></a> for computing Yn(x), and   its first and second derivatives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inkydragon/PureSpecial.jl/blob/a07472ced3765e78d6b4c1fd42ad193d14889531/src/specfun/bessel_zeros.jl#L719-L734">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../book-index/">« Function Index in CoSF</a><a class="docs-footer-nextpage" href="../../cephes/">Cephes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 9 January 2026 17:17">Friday 9 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
